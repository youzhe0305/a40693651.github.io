<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>&lt;演算法教學&gt; BIT資料結構</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-BIT/</url>
    <content><![CDATA[<p>BIT(Binary Indexed Tree)，樹狀數組，用來維護區間的資料結構，一般情況下，我們會用它處理單點修改區間查詢的區間加值問題，當然他也可以處理更複雜的問題，不過就要搭配差分等，其他的資料結構，這裡暫且不談。</p>
<p>BIT的核心概念是倍增，每個區間都可以使用2的次方長度的子區間構成，所以我們只要維護2的次方長度的區間。舉例來說，7的二進制是1101，也就是他可以用1~4、5~6、7三個區間組成。</p>
<p>我們實際需要維護的區間如下圖，以每個數字的格子作為尾端，做一個區間，區間的長度是該數字轉成二進制後，最右邊的1代表的值，像是6=110，最右邊的1是在第2位，也就是2的1次方。<br><img src="/演算法教學/algorithm-BIT/BIT.png" alt=""></p>
<p>至於為什麼會這樣，是因為我們每前進一個數字，就會從二進制的最右端+1，這時候可能會發生進位，但不論如何進位，該數字都會在最右端的區間裡，所以取最右端的1當作區間長度，再更左的1，就用這個數字之前的區間構成。</p>
<p>這裡我們定義x轉成二進制後，最右端的1為lowbit(x)，在數學上的計算方法中，剛好會是(x&amp;-x)的值，至於為什麼我就不知道了。</p>
<p>BIT與線段樹的主要差別就是，他的空間只需要N，因為存的是以每個數字當尾端的區間值，所以區間值的數量剛好會跟數字一樣多，也就是N，比線段樹的4N小。另外，BIT的常數也比線段樹小一點。</p>
<p>接下來講講BIT的具體實現方法。</p>
<h3 id="區間查詢"><a href="#區間查詢" class="headerlink" title="區間查詢"></a>區間查詢</h3><p>如上所提到的，一個從1開始的區間可以變成二進制的底下，所有1代表的區間構成，所以我們就要一一找出對應的區間。</p>
<p>假設我們要找1~6，該數字6會在最右邊的區間，也就是lowbit(6)，所以我們先把答案加上這個區間的值，然後數字減去這個區間的長度，以6為例，就是減掉5~6的區間長2，變成4，換成二進制就是110去掉最右邊的1，變成100，這樣4又變成了lowbit(4)的尾端了，這樣重複做下去，直到0就可以獲得1~x的區間值。</p>
<p>當我們想要得到，l~r的區間值時，只要用前綴和的方法。1~r減去1~(l-1)，就可以了。</p>
<p>複雜度: $O(logN)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> bit[], <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ans += bit[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="單點修改"><a href="#單點修改" class="headerlink" title="單點修改"></a>單點修改</h3><p>單點修改想起來就比較抽象了，當我們修改其中一個點時，我們就要連帶修改所有會被影響到的區間，而這些區間，從BIT圖可以看出，就是以這個點所在的區間開始，向上找父區間(包含到該區間的區間)。</p>
<p>從BIT圖中，可以看出，只要加上該點的區間長度，就會變成他往上一個的父區間，也就是加上lowbit(x)。往上的父區間出現變動時，一樣加上lowbit，就可以找到更上面被影響到的區間。</p>
<p>複雜度: $O(logN)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> bit[], <span class="type">int</span> x, <span class="type">int</span> val)</span></span>&#123; <span class="comment">// 直接用加的比較好寫</span></span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        bit[x] += val;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="建立BIT"><a href="#建立BIT" class="headerlink" title="建立BIT"></a>建立BIT</h3><p>既然我們掌握了單點修改的方法，只要對每個點做修改，就可以做到初始的建立了，複雜度: $O(NlogN)$</p>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/109918259">伊地知虹夏</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>資料結構</tag>
        <tag>區間</tag>
        <tag>BIT</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; Floyd-Warshall多點源最短路演算法</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-Floyd-Warshall/</url>
    <content><![CDATA[<p>Floyd-Warshall演算法，弗洛伊德演算法，用來解決多點源最短路問題的演算法。</p>
<p>相較於Dijkstra及SPFA只能找到對於一個起點的最短路徑，Floyd-Warshall可以用來找到圖上任意點對任意點的最短路徑。</p>
<p>Floyd-Warshall的概念相對起來好懂很多，就是幹下去就對了，用每一個點去鬆弛每一個點。直接用for迴圈枚舉就行，就直接看code吧</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><p>時間複雜度$O(N^3)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> dp[MAXN]; <span class="comment">// 表示最短距離</span></span><br><span class="line"><span class="type">void</span> Floyd-<span class="built_in">Warshall</span>()&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; dp[i][k] + dp[k][j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i][k] + dp[k][j]; <span class="comment">// 當可以被鬆弛，則更新</span></span><br><span class="line">                &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/106493951">ん…ちょっと寂しかった……</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>最短路</tag>
        <tag>Floyd-Warshall</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm-KMP</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-KMP/</url>
    <content><![CDATA[<h2 id="KMP演算法"><a href="#KMP演算法" class="headerlink" title="KMP演算法"></a>KMP演算法</h2><p>KMP(Knuth–Morris–Pratt)是一個字串演算法，他可以比對一個小字串、一個大字串，看大字串中是否有出現小字串，出現了幾個，位置在哪裡</p>
<p>ex: 找出abc在abcdabc中，出現了2次，位置分別在s[2]結尾跟s[6]結尾的地方。</p>
<h2 id="KMP的前導，Next表"><a href="#KMP的前導，Next表" class="headerlink" title="KMP的前導，Next表"></a>KMP的前導，Next表</h2><p>在講KMP之前，我們要先來了解甚麼是Next表，Next表是一個陣列，用來儲存一個字串的前綴跟後綴，一樣的東西最長有多長。</p>
<p>先講前綴後綴是甚麼，以abcdefg來講，從a開頭往後延伸的，a, ab, abc…都算是前綴，以g結尾，往前延伸的，g, fg, efg…都算是後綴。</p>
<p>Next表存的就是，到第i個字為止，在他的前後綴的同樣配對中(不包括整個字串做為前綴or後綴)，最長的有多長，以abcdabc舉例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">abcab</span><br><span class="line">00012 // next表</span><br><span class="line">i=1 no</span><br><span class="line">i=2 no</span><br><span class="line">i=3 no</span><br><span class="line">i=4 <span class="string">&#x27;a&#x27;</span>bc<span class="string">&#x27;a&#x27;</span>有長度為1</span><br><span class="line">i=5 <span class="string">&#x27;ab&#x27;</span>c<span class="string">&#x27;ab&#x27;</span>有長度為2</span><br><span class="line">當然，也可以有前後綴重疊的時候</span><br><span class="line">ababa在i=5的時候，就有<span class="string">&#x27;aba&#x27;</span>ba跟ab<span class="string">&#x27;aba&#x27;</span>，長度為3</span><br></pre></td></tr></table></figure>
<p>至於要怎麼找，讓我們從最暴力的方式慢慢優化它。</p>
<h3 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解:"></a>暴力解:</h3><p>直接一一比對，每個i都做一次，然後從最長的可能狀況枚舉next的長度，如果不成立就-1，一直枚舉到成立或是0，就是最長的的狀況了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> next[<span class="number">100</span>];</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一個數一定會是0</span></span><br><span class="line"><span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="comment">// 從第2個數開始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--)&#123; <span class="comment">// 枚舉長度，總長為i+1，所以最長是i</span></span><br><span class="line"><span class="comment">// substr用來找子字串，參數(開始的位置，子字串長度)</span></span><br><span class="line">  <span class="keyword">if</span> (str.<span class="built_in">substr</span>(<span class="number">0</span>, j) == str.<span class="built_in">substr</span>(i - j + <span class="number">1</span>, j)) &#123; <span class="comment">// 比對是否一樣</span></span><br><span class="line">    next[i] = j;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>複雜度為$O(N^3)$，枚舉子字串(i)長度$O(N)$，枚舉next長度$O(N)$，比對字串複雜度$O(N)$</p>
<h2 id="優化1"><a href="#優化1" class="headerlink" title="優化1"></a>優化1</h2><p>在枚舉子字串的過程中，每次都只會比上一次多了一個字元，next最多就是+1，因此我們在枚舉長度的時候，不用每次都從最長枚舉，只要從上一個子字串(i-1)的next值+1做為最長的可能長度就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> next[<span class="number">100</span>];</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = next[i<span class="number">-1</span>]+<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123; <span class="comment">// 最長只要枚舉上一個子字串next值+1</span></span><br><span class="line">  <span class="keyword">if</span> (str.<span class="built_in">substr</span>(<span class="number">0</span>, j) == str.<span class="built_in">substr</span>(i - j + <span class="number">1</span>, j)) &#123; <span class="comment">// </span></span><br><span class="line">    next[i] = j;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>複雜度為$O(N^2)$，枚舉子字串(i)長度$O(N)$，比對時最糟情況是慢慢累加x次之後，一次跳到0，該次就得讓j從x跑到0，總體來講，會有$O(N/2)的複雜度$</p>
<h2 id="優化2-KMP用到的最終優化"><a href="#優化2-KMP用到的最終優化" class="headerlink" title="優化2(KMP用到的最終優化)"></a>優化2(KMP用到的最終優化)</h2><p>建立在第一個優化之上，我們可以發現，當多加上一個字元時，next不是+1(str[i]!=str[ next[i-1] ])，匹配沒有成功，其實我們不需要用-1,-1,-1…的方式縮減next的長度。</p>
<p>以axacaxax為例，當i=7，準備加入a時，這時前一個的next是3(‘axa’c’axa’)，所以最長next設為4，發現c跟x不匹配。這時候我們會想試試看next=3，不過這是沒有必要的。</p>
<p>因為i=6時的前綴跟後綴長的一樣，都是’axa’，所以不可能選擇next為3的，因為這代表要從後綴取後面2個’xa’(第3個是要加入的a)，從前綴取前面2個’ax’，光是在這裡就不匹配了。</p>
<p>可以看出要找到下一個可能可以用的長度有個關鍵，因為前綴跟後綴的字串一樣，是前一個next取得的子字串，所以可以視為一個單一字串str2。”str2中，必須有前綴跟後綴相同的情況，才有可能去嘗試匹配”</p>
<p>以這題來說，’axa’相同的前後綴是’a’x’a’，所以帶有新的a的next，只有可能前面a或是更短，不會是ax。而i=7的next值也的確是2(‘ax’acax’ax’)</p>
<p>總結來講，當我們要做縮減時，我們應該找到那個上一個子字串中，next字串的next字串，並嘗試，失敗就繼續找，直到值為0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> next[<span class="number">100</span>];</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">string str;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123; </span><br><span class="line">    <span class="type">int</span> prenext = next[i<span class="number">-1</span>]; <span class="comment">// 前一位的最長next</span></span><br><span class="line">    <span class="keyword">if</span>(str[i]==str[prenext])&#123; </span><br><span class="line">        next[i] = prenext+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(str[i]!=str[prenext])&#123; <span class="comment">// 如果不是，則開始找next字串的next長度</span></span><br><span class="line">            prenext = next[prenext<span class="number">-1</span>]; <span class="comment">// next字串的右端點到prenext-1。帶進next陣列的索引就可以得到這個next字串的next值</span></span><br><span class="line">            <span class="keyword">if</span>(prenext==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prenext==<span class="number">0</span>)&#123; <span class="comment">// 找不到的情況有兩種，字串尾端可以跟頭匹配，或是不行</span></span><br><span class="line">            <span class="keyword">if</span>(str[i]==str[<span class="number">0</span>]) next[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> next[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 匹配成功的話，值會是該長度+1(長度為新next字串的前面長度，再加上新加入的字元)</span></span><br><span class="line">            next[i] = prenext+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>複雜度是$O(N)$，枚舉子字串(i)長度$O(N)$，找next的複雜度$O(2)$(我不會證明)</p>
<h2 id="用Next表來做KMP"><a href="#用Next表來做KMP" class="headerlink" title="用Next表來做KMP"></a>用Next表來做KMP</h2><p>知道Next表之後，我們只要把小字串s1跟大字串s2拼在一起，變成s1+’#’+s2就行了。中間的’#’是用來分隔兩個字串的。</p>
<p>透過這個方式，只要在Next表中，看到數值=小字串長度l，就代表這個地方出現了小字串(前綴的l個就是小字串)，並且這個點是出現的小字串結尾。</p>
<p>由此便可以獲悉: 是否出現、數量、位置</p>
<p>模板題: <a href="https://www.luogu.com.cn/problem/P3375">P3375 【模板】KMP 字符串匹配</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> nexttable[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">next_build</span><span class="params">(string str)</span></span>&#123; <span class="comment">// 建立next表</span></span><br><span class="line"></span><br><span class="line">    nexttable[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> prenext = nexttable[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(str[i]!=str[prenext])&#123;</span><br><span class="line">            prenext = nexttable[prenext<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(prenext==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nexttable[i] = prenext;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==str[prenext])</span><br><span class="line">            nexttable[i]++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">string str1,str2;</span><br><span class="line">cin&gt;&gt;str1;</span><br><span class="line">cin&gt;&gt;str2;</span><br><span class="line"></span><br><span class="line">string str = str2 + <span class="string">&quot;#&quot;</span> + str1; <span class="comment">// 把兩個字串結合起來，就可以套用next表了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">next_build</span>(str); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=str2.<span class="built_in">length</span>()+<span class="number">1</span>;i&lt;str.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nexttable[i]==str2.<span class="built_in">length</span>()) cout&lt;&lt; i - <span class="number">2</span>*str2.<span class="built_in">length</span>() + <span class="number">1</span>&lt;&lt;endl; \</span><br><span class="line">    <span class="comment">// 當next表做完之後，找有沒有包含前綴長度str2.length的，有就代表這個字串完整的出現在了以i為右界的後綴(str1)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str2.<span class="built_in">length</span>();i++)</span><br><span class="line">    cout&lt;&lt;nexttable[i]&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 就照題目輸出str2的next表</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>參考資料:<a href="https://oi-wiki.org/string/kmp/">OI Wiki</a></p>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/103885785">伊地知虹夏</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>字串</tag>
        <tag>Next表</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; SPFA單點源最短路演算法</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-SPFA/</url>
    <content><![CDATA[<p>SPFA(Shortest Path Faster Algorithm)，最短路徑快速算法，帶有queue優化的Bellman-Ford算法。(因為SPFA比較常用，就直接講SPFA，Bellman-Ford就請有興趣的人去再去研究)</p>
<p>這個演算法通常用來解決圖上可能有負環的情況，也就是我們上一篇提到，Dijkstra演算法無法解決的狀況。讓我們先來看看，有負環的情況下，會發生甚麼事?</p>
<p><img src="/演算法教學/algorithm-SPFA/negative-loop.gif" alt=""></p>
<p>可以發現他會進入一個無限迴圈，一直在負環裡面跑，讓負環上的點的距離值不斷被更新、變小。</p>
<p>也就是說，存在負環的狀況下，我們不可能找到最短路徑，因為路徑會不斷變短。所以我們要使用SPFA來解決這個問題，判斷負環是否存在。</p>
<p>判斷負環是否存在的關鍵，在於更新次數。首先讓我們想想一個點最多被更新幾次?顯然是n-1次，因為只能被其他點各鬆弛一次，當一直被重複更新時，更新次數就會超過n-1，也就是出現了負環，SPFA也就是針對此判斷。</p>
<p>SPFA與Bellman-Ford差別最大的是在於queue的優化，Bellman-Ford會直接不管三七二十一的，直接跑n-1次。這裡則利用類似BFS的方式來做優化，讓他不用跑滿n-1次。</p>
<p>SPFA很像BFS，就是從起點開始，一直往下跑，看下面的點能不能被當前的點更新到，最大的差別是，SPFA是可以往回跑到重複的點的，也就是可以在後面更新出更短的路徑時，跑回去更新前面的點，就因此解決了BFS只能解決邊權唯一圖形的狀況。</p>
<p>跑的過程中，如果可以更新，就記錄更新次數加一，如果更新次數超過了n-1，代表重複更新，有負環存在。如果沒有超過的話，更新完的值也是更新到不能再更新了。</p>
<p>其中，我們在queue的使用上，會用inque來記錄這個點是否在queue裡面，如果一個點已經在queue裡面，代表他即將被用來更新其他點，這時候就算被更新一個新的距離，也不必再把他丟進去一次，只要把distance陣列中的值改掉，在更新的時候就會使用最小的值。</p>
<p>ex: 有a-&gt;c,距離10的路，b-&gt;c距離5的路，假設dis[a]=3,dis[b]=5，dis[c]先被更新成dis[a]+10=13丟進queue裡面，接著dis[c]又被更新成dis[b]+5=10，這時候就不用再丟進queue一次，因為從queue拿出來的時候，會以當下的dis[c]來鬆弛其他點，也就是dis[c]=10。</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><p>時間複雜度$O(NM)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> dis[MAXN]; <span class="comment">// 距離</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que; </span><br><span class="line"><span class="type">int</span> inque[MAXN]; <span class="comment">// 記錄這個點是不是在queue裡面</span></span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> n)</span></span>&#123; <span class="comment">// 以v當作起點，有n個點</span></span><br><span class="line">	dis[v] = <span class="number">0</span>;</span><br><span class="line">	que.<span class="built_in">push</span>(v);</span><br><span class="line">	inque[v] = <span class="number">1</span>; <span class="comment">// 點v進入queue</span></span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		inque[u] = <span class="number">0</span>; <span class="comment">// 點v離開queue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(pii i:vec[u])&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[i.F] &gt; dis[u]+i.S)&#123; <span class="comment">// i.S 表示邊權</span></span><br><span class="line">				num[i.F]++;</span><br><span class="line">				<span class="keyword">if</span>(num[i.F] &gt; n<span class="number">-1</span>)&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果更新次數大於n-1，代表重複更新，有負環存在</span></span><br><span class="line">				&#125;</span><br><span class="line">				dis[i.F] = dis[u]+i.S;</span><br><span class="line">				<span class="keyword">if</span>(inque[i.F]==<span class="number">0</span>)&#123;</span><br><span class="line">					que.<span class="built_in">push</span>(i.F);</span><br><span class="line">					inque[i.F]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/104987258">伊地知 虹夏</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>最短路</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; Kruskal最小生成樹演算法</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-Kruskal/</url>
    <content><![CDATA[<p>Kruskal，克魯斯克爾演算法，用貪心的方式，找出一張圖裡面，能連到所有邊的樹中，權值最小的，也就是<a href="https://zh.wikipedia.org/zh-tw/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成樹(MST)</a></p>
<p><img src="/演算法教學/algorithm-Kruskal/MST.PNG" alt=""></p>
<p>首先，將所有邊排序一遍，依次把最小的邊與其連到的點加入最小生成樹的子圖中，等到所有點都被加入後，就能得到最小生成樹。要注意的是，在加入邊時，要避免子圖中出現環，不然就不會是樹了。</p>
<p>實作上，我們會利用並查集來檢查點是否已經在最小生成樹裡面，以及是否成環。</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><p>(以上圖作為範例輸入輸出)<br>時間複雜度$O(MlogM)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pip pair<span class="string">&lt;int,pair&lt;int,int&gt;</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;pip&gt; vec; <span class="comment">// 儲存邊</span></span><br><span class="line"><span class="type">int</span> p[MAXN]; <span class="comment">// 父節點</span></span><br><span class="line"><span class="type">int</span> s[MAXN]; <span class="comment">// 集合大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		p[i] = i, s[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p[v] == v ? v : p[v] = <span class="built_in">find</span>(p[v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">	p[pa] = pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(pip i:vec)&#123;</span><br><span class="line">		<span class="type">int</span> a = i.S.F, b = i.S.S;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="keyword">continue</span>;<span class="comment">// 在同個集合下，也就是成環，試著加入重複點</span></span><br><span class="line">		<span class="built_in">uni</span>(a,b);</span><br><span class="line">		ans += i.F; <span class="comment">// 確定加入最小生成樹後，把權重加入答案</span></span><br><span class="line">	<span class="comment">// 當所有邊都跑完，就可以確定所有點都都被加進去</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="type">int</span> a,b,w;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">	vec.<span class="built_in">push_back</span>(&#123; w, <span class="built_in">make_pair</span>(a, b) &#125;); <span class="comment">// 加入邊(權重放第一位，才能排序)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">kruskal</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input:</span><br><span class="line">5 6</span><br><span class="line">1 3 5</span><br><span class="line">1 4 1</span><br><span class="line">2 4 7122</span><br><span class="line">2 5 2</span><br><span class="line">3 5 5</span><br><span class="line">4 5 5</span><br></pre></td></tr></table></figure><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">13</span><br></pre></td></tr></table></figure></p>
<p>喔對，還有今天是虹夏的生日，都來祝他生日快樂</p>
<p><img src="/演算法教學/algorithm-Kruskal/108513584.jpg" alt=""></p>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/108513584">スーパー虹夏ちゃんまとめ</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>最小生成樹</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; ST表資料結構</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-ST/</url>
    <content><![CDATA[<p>ST表，Sparse-Table演算法，用來解決可重複貢獻的區間問題，也就是求大區間時，可以用兩個重疊的小區間獲得(通常就是用來解區間最大最小值，區間加值因為重疊會累加，所以不行)</p>
<p>ST表使用了倍增的方式，先建好所有2的次方數長度的區間，然後把任意區間用兩個長度大於區間一半的子區間去構成，如圖:</p>
<p><img src="/演算法教學/algorithm-ST/st-preprocess-lift.svg" alt=""><br>(圖取自:<a href="https://oi-wiki.org/ds/sparse-table/">OI wiki</a>)</p>
<p>利用兩個長度4的區間，直接算出長度6的區間的最大值，而這兩個長度4的區間，會在我們ST表裡面(2的次方)。</p>
<p>這樣的算法中，因為我們以每個點為起點，建構2的次方長度的區間，建構的複雜度為$O(NlogN)$，在查詢時，只要兩個ST表的值取極值，所以複雜度是$O(1)$，這也是他比線段樹優勢的地方，雖然差不太多就是了。</p>
<p>實作如下:</p>
<p>令ST表為，$ST[i][j]$，$i$代表起點，$j$代表長度為2^j次方。<br><img src="/演算法教學/algorithm-ST/ST-len-interval.png" alt=""><br>初始化讓$ST[i][0]$為$i$位置的值，然後用下列式子轉移<br>$ST[i][j] = max(ST[i][j-1],ST[i+2^{j-1}][j-1])$<br>也就是把一個$2^j$長度的區間，用兩個$2^{j-1}$長度的區間構成</p>
<p>接著就可以開始查詢了，一個區間的數值，會是兩個區間之間去找，這兩個區間的長度要是第一個大於等於區間一半長度的2次方，並分別從頭尾延伸向中間。<br>假設最左為$l$最右為$r$，子區間長度為$2^s$，轉移式如下:<br>$ans = max(ST[l][s],ST[r-2^s+1][s])$</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOGN = <span class="built_in">log2</span>(MAXN)+<span class="number">1</span>; <span class="comment">// 最大的log值</span></span><br><span class="line"><span class="type">int</span> arr[MAXN]; <span class="comment">// 儲存資料</span></span><br><span class="line"><span class="type">int</span> logn[MAXN]; <span class="comment">// 某個數字的log值向下取整，也就是大於區間一半的第一個2的次方數</span></span><br><span class="line"><span class="type">int</span> st[MAXN][LOGN]; <span class="comment">// ST表</span></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// n:資料數量, m:詢問數量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_log</span><span class="params">()</span></span>&#123; <span class="comment">// 預處理log值</span></span><br><span class="line">    logn[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    logn[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=MAXN;i++)</span><br><span class="line">        logn[i] = logn[i/<span class="number">2</span>] + <span class="number">1</span>; <span class="comment">// 這個整數小於真正的log值，但不會差到1，所以可以覆蓋到一半以上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 初始化ST表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        st[i][<span class="number">0</span>] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pre_log</span>();</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=LOGN;j++)&#123; <span class="comment">// 枚舉不同長度的區間，直到最大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j) - <span class="number">1</span> &lt;=n;i++) <span class="comment">// st表的儲存範圍 = (i,i+2^j - 1)(長度2^j)</span></span><br><span class="line">            st[i][j] = <span class="built_in">max</span>( st[i][j<span class="number">-1</span>], st[i + (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>] ); <span class="comment">// 用兩個長度2^(j-1)的區間構成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123; <span class="comment">// m次</span></span><br><span class="line">        <span class="type">int</span> l,r; <span class="comment">// 區間的左右端點</span></span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="type">int</span> len = r-l+<span class="number">1</span>; <span class="comment">// 區間長度</span></span><br><span class="line">        <span class="type">int</span> s = logn[len]; <span class="comment">// 涵蓋一半的2的次方數</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(st[l][s],st[ r - (<span class="number">1</span>&lt;&lt;s) +<span class="number">1</span> ][s]);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意: &lt;&lt;的位移符號，依然遵循由左到右計算，並沒有優先，所以要括號</p>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/103493690">あぐらかいてる虹夏ちゃん</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>資料結構</tag>
        <tag>區間</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; 並查集資料結構</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-Disjoint-Set/</url>
    <content><![CDATA[<p>並查集(Disjoint-set)，用來處理物品是否同一群的資料結構，他可以做到合併、查詢集合的功能，所以稱為並查集。</p>
<p>我們透過紀錄每個點的父節點來達成，當兩個點被歸類到同一集合時，我們以這個集合的根最為父節點，我這裡稱為最終父節點。</p>
<p>查詢時，如果有兩個點的最終父節點相同，即代表他們在同個集合裡。</p>
<p>合併時，把其中一個集合的最終父節點，定為另一個集合的最終父節點，讓兩者最終父節點相同，即達成合併。</p>
<p>另外，合併有個優化的方法，稱為啟發式合併，在啟發式合併裡，我們選擇把比較小的集合併到比較大的集合中，這樣當這個比較小的集合要更新成新的父節點時，只要走更少的路。</p>
<p>這東西直接看code會更好懂一點。</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code"></a>示範code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[MAXN]; <span class="comment">// 節點的父節點</span></span><br><span class="line"><span class="type">int</span> s[MAXN]; <span class="comment">// 集合大小(size)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">//　初始化先把自己的父節點設為自己，並把集合大小設為1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		p[i] = i, s[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> v)</span></span>&#123; <span class="comment">// 查詢父節點</span></span><br><span class="line">	<span class="comment">// 看父節點是不是自己，不是就往上找父節點，直到最終父節點(父節點=自己)</span></span><br><span class="line">	<span class="keyword">return</span> p[v] == v ? v : p[v] = <span class="built_in">find</span>(p[v]); <span class="comment">// 順便把點的父節點更新成最終父節點</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="comment">// 合併兩個集合</span></span><br><span class="line">	<span class="comment">// 讓a集合的最終父節點，變成b集合的最終父節點</span></span><br><span class="line">	<span class="comment">//  讓a集合並到b集合上</span></span><br><span class="line">	<span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">	p[pa] = pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uni_inspire</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123; <span class="comment">// 啟發式合併版本</span></span><br><span class="line">	<span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(s[pa]&gt;s[pb]) <span class="built_in">swap</span>(pa,pb) <span class="comment">// 保持b團體更大</span></span><br><span class="line">	p[pa] = pb; <span class="comment">// 把小的a集合並到b集合上</span></span><br><span class="line">	s[pb] += s[pa]; <span class="comment">// 把size相加</span></span><br><span class="line">	s[pa] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>喔對，還有今天是虹夏的生日，都來祝他生日快樂</p>
<p><img src="/演算法教學/algorithm-Disjoint-Set/108535311.jpg" alt=""></p>
<p><a href="https://www.pixiv.net/artworks/108535311">【ぼっち・ざ・ろっく！】虹夏ちゃん誕生日おめでとうイラスト</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>集合</tag>
        <tag>並查集</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; 拓樸排序演算法</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-Topological-Sorting/</url>
    <content><![CDATA[<p>拓樸排序(Topological Sorting)用於<a href="https://zh.wikipedia.org/zh-tw/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE">有向無環圖(DAG)</a>上，可以排出一個節點順序，保證每個節點被經過時，前面指向他的節點都已經被經過。</p>
<p>可以用於任務有前置條件時，對任務的排序，或是最長路徑的計算。</p>
<p>示例圖:<br>(黑字:點編號, 紅字:執行順序)</p>
<p><img src="/演算法教學/algorithm-Topological-Sorting/task_sort.PNG" alt=""></p>
<p>拓樸排序的核心在於，不斷找出入度為0的點，也就是沒有任何前置任務，可以直接執行的任務。</p>
<p>一開始，我們先找到初始入度為0的點，並把他加入我們的工作執行序列裡。接著，當我們從工作執行序列裡，將其取出並執行完成後，把它指向的節點，入度全部減一，代表前置任務被完成了一項。如果這些節點有入度成為0的點，代表他也可以直接執行，所以加入工作執行序列中，就這樣一路做到底，就完成了拓樸排序了。</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><p>時間複雜度$O(N)$<br>(以上圖為例)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> rd[MAXN]; <span class="comment">// 入度</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec[MAXN]; <span class="comment">// 存圖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">// 執行函式</span></span><br><span class="line">	cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; que; <span class="comment">// 工作序列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(rd[i]==<span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">do_func</span>(u); <span class="comment">// 執行這個任務</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:vec[u])&#123;</span><br><span class="line">			rd[i]--; <span class="comment">// 因為前一個任務被執行完，所以入度減一</span></span><br><span class="line">			<span class="keyword">if</span>(rd[i]==<span class="number">0</span>) que.<span class="built_in">push</span>(i); <span class="comment">// 沒有前置序列，加入最長路</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m; <span class="comment">// 點數,邊數</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		vec[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		rd[b]++; <span class="comment">// 被指向，所以b的入度+1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">topo</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input:</span><br><span class="line">5 5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>喔對，還有今天是虹夏的生日，都來祝他生日快樂</p>
<p><img src="/演算法教學/algorithm-Topological-Sorting/108530112.jpg" alt=""></p>
<p><a href="https://www.pixiv.net/artworks/108530112">虹夏ちゃん誕生日おめでとう🎉🎉🎉【2023】</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>DAG</tag>
        <tag>拓樸排序</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; Prim最小生成樹演算法</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-Prim/</url>
    <content><![CDATA[<h1 id="臨時打字用"><a href="#臨時打字用" class="headerlink" title="臨時打字用"></a>臨時打字用</h1><p>Prim，普林演算法，用類似Dijkstra的方式，找出一張圖裡面，能連到所有邊的樹中，權值最小的，也就是<a href="https://zh.wikipedia.org/zh-tw/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成樹(MST)</a></p>
<p><img src="/演算法教學/algorithm-Prim/MST.PNG" alt=""></p>
<p>首先，類似於Dijkstra的作法，先從圖中挑一個點，把邊都丟進priority_queue中，找出目前的最小邊。</p>
<p>因為我們保證每個點都會被用到所以要連接到一個點，可以從其他任意點過來，也就是可以挑這個點的任意邊。那自然我們會挑最小的那條邊。</p>
<p>接著我們看這個邊連到誰，把邊丟進priority_queue裡面，繼續挑最小的往下做。如果遇到挑最小邊可能成環的狀況，就不要挑這條邊。</p>
<p>因為挑了意味著必須把另一條相對的邊去掉，但是其他會成環的邊，一定是在最小生成樹內，也就是priority_queue篩選出來比這個邊更小的邊，才會形成環，所以這個替換必然會造成權值更大，所以不挑。</p>
<p>ex:<br><img src="/演算法教學/algorithm-Prim/Prim.PNG" alt=""><br>當我們在挑下一條邊時，最小邊是3，但是他會連回到A點形成環。如果要把這個3的最小邊接起來，勢必要去掉1或2這兩條邊，那這個替換顯然不好，所以我們改挑下一條長度4的邊</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><p>(以上圖作為範例輸入輸出)<br>時間複雜度$O(NlogN)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;pii&gt; vec[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq; <span class="comment">// 用來排列目前最小邊</span></span><br><span class="line">	pq.<span class="built_in">push</span>(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">// 放入一個點當源點</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line"></span><br><span class="line">		pii u = pq.<span class="built_in">top</span>();</span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[u.S]) <span class="keyword">continue</span>; <span class="comment">//這個點已經被挑過</span></span><br><span class="line">		vis[u.S] = <span class="number">1</span>;</span><br><span class="line">		ans += u.F <span class="comment">// 加入權值</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(pii i:vec[u])&#123;</span><br><span class="line">			<span class="type">int</span> point = i.F, w = i.S;</span><br><span class="line">			pq.<span class="built_in">push</span>(&#123;w,point&#125;) <span class="comment">// 權值放前面，來能用來排序</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="type">int</span> a,b,w;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b,w;</span><br><span class="line">	vec[a].<span class="built_in">push_back</span>(&#123;b,w&#125;);</span><br><span class="line">	vec[b].<span class="built_in">push_back</span>(&#123;a,w&#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">Prim</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input:</span><br><span class="line">5 6</span><br><span class="line">1 3 5</span><br><span class="line">1 4 1</span><br><span class="line">2 4 7122</span><br><span class="line">2 5 2</span><br><span class="line">3 5 5</span><br><span class="line">4 5 5</span><br></pre></td></tr></table></figure><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">13</span><br></pre></td></tr></table></figure></p>
<p>喔對，還有今天是虹夏的生日，都來祝他生日快樂</p>
<p><img src="/演算法教學/algorithm-Prim/1662836880839430145.jpg" alt=""></p>
<p>封面圖來源: <a href="https://twitter.com/KKito55/status/1662836880839430145">伊地知虹夏生誕祭2023</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>最小生成樹</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P1351 [NOIP2014 提高組] 聯合權值</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P1351/</url>
    <content><![CDATA[<h2 id="題目-P1351-NOIP2014-提高組-聯合權值"><a href="#題目-P1351-NOIP2014-提高組-聯合權值" class="headerlink" title="題目: P1351 [NOIP2014 提高組] 聯合權值"></a>題目: <a href="https://www.luogu.com.cn/problem/P3387">P1351 [NOIP2014 提高組] 聯合權值</a></h2><p>原本看這題的tag，以為會是難題，結果其實滿水的</p>
<p>首先，n個點n-1個邊，顯然是一棵樹，接著他要求距離為2的點對，那顯然是中間跨過一個點，所以我們只要找出每個點作為中間點的情況，然後把他們兩兩組合就好了。</p>
<p>另外，最大值只要把中間點連到的點，找出最大的兩個點相乘，就可以得到這個中間點能創造的最大權值，把每個點比一遍就好。</p>
<p>要注意的是，他的最大值不要求取模，我就被這卡了好一陣子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">10007</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[MAXN];</span><br><span class="line"><span class="type">int</span> w[MAXN];</span><br><span class="line"><span class="type">int</span> child[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  vis[v] = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> mx_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> mx_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i : tree[v]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w[i] &gt; mx_1)</span><br><span class="line">      mx_2 = mx_1, mx_1 = w[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (w[i] &gt; mx_2)</span><br><span class="line">      mx_2 = w[i];</span><br><span class="line">      </span><br><span class="line">    ans = (ans + (child[v] * w[i]) % mod) % mod;</span><br><span class="line">    child[v] = (child[v] + w[i]) % mod;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      <span class="built_in">DFS</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mx = <span class="built_in">max</span>(mx, mx_1 * mx_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    tree[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    tree[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DFS</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; mx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (ans * <span class="number">2</span>) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/104327420">虹夏ちゃん</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>DFS</tag>
        <tag>普及+/提高</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P1541 [NOIP2010 提高組] 烏龜棋</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P1541/</url>
    <content><![CDATA[<h2 id="題目-P1541-NOIP2010-提高組-烏龜棋"><a href="#題目-P1541-NOIP2010-提高組-烏龜棋" class="headerlink" title="題目: P1541 [NOIP2010 提高組] 烏龜棋"></a>題目: <a href="https://www.luogu.com.cn/problem/P1541">P1541 [NOIP2010 提高組] 烏龜棋</a></h2><p>這題很顯然是個標準的DP，我一開始的想法是，直接開一個5維的陣列$dp[格子數][卡片1][卡片2][卡片3][卡片4]$，枚舉格子數去做線性dp，但這樣會直接RE。所以勢必要把<strong>格子數</strong>去掉，陣列才可能放得下，後來發現格子數其實就是使用的卡片數量乘以權值加總，所以就可以直接丟掉格子數，改成枚舉4種卡片的數量。</p>
<p>轉移式變成以下:<br>使用卡片1:</p>
<p>$dp[卡片1][卡片2][卡片3][卡片4] = dp[卡片1 - 1][卡片2][卡片3][卡片4] + arr[step]$</p>
<p>arr是儲存格子權值的陣列，step是當前的位置，也就是卡片數量乘以權值加總。<br>其他以此類推…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">355</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">45</span>; <span class="comment">// 40^4 = 2.5e6 是可以接受的空間複雜度</span></span><br><span class="line"><span class="type">int</span> arr[MAXN]; <span class="comment">// 儲存格子權值</span></span><br><span class="line"><span class="type">int</span> card[<span class="number">5</span>]; <span class="comment">// 儲存卡片數量</span></span><br><span class="line"><span class="type">int</span> dp[MAXM][MAXM][MAXM][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    cin&gt;&gt;arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    card[a]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">1</span>]; <span class="comment">// 初始站在起點，把起點的值加進來</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=card[<span class="number">1</span>];i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=card[<span class="number">2</span>];j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=card[<span class="number">3</span>];k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=card[<span class="number">4</span>];l++)&#123;</span><br><span class="line">                <span class="type">int</span> step = <span class="number">1</span> + i*<span class="number">1</span> + j*<span class="number">2</span> + k*<span class="number">3</span> + l*<span class="number">4</span>; <span class="comment">// 起始點是1，所以用完當下這些卡片會到的格子要+1</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">                    dp[i][j][k][l] = <span class="built_in">max</span>(dp[i][j][k][l], dp[i<span class="number">-1</span>][j][k][l] + arr[step]);</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">                    dp[i][j][k][l] = <span class="built_in">max</span>(dp[i][j][k][l], dp[i][j<span class="number">-1</span>][k][l] + arr[step]);</span><br><span class="line">                <span class="keyword">if</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">                    dp[i][j][k][l] = <span class="built_in">max</span>(dp[i][j][k][l], dp[i][j][k<span class="number">-1</span>][l] + arr[step]);</span><br><span class="line">                <span class="keyword">if</span>(l&gt;<span class="number">0</span>)</span><br><span class="line">                    dp[i][j][k][l] = <span class="built_in">max</span>(dp[i][j][k][l], dp[i][j][k][l<span class="number">-1</span>] + arr[step]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;dp[ card[<span class="number">1</span>] ][ card[<span class="number">2</span>] ][ card[<span class="number">3</span>] ][ card[<span class="number">4</span>] ]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/107025668">イメチェン꒰ঌ ( ˶’ᵕ’˶) ໒꒱｢に、似合うかな….｣</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>普及+/提高</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P2014 [CTSC1997] 選課</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P2014/</url>
    <content><![CDATA[<h2 id="題目-P2014-CTSC1997-選課"><a href="#題目-P2014-CTSC1997-選課" class="headerlink" title="題目: P2014 [CTSC1997] 選課"></a>題目: <a href="https://www.luogu.com.cn/problem/P2014">P2014 [CTSC1997] 選課</a></h2><p>這種選課的題目，我第一個想法是DAG，不過後來想了想，用DAG來求最大值好像不太好做。所以就改成我們常常用來求最大值的方法—-DP</p>
<p>這題要進行DP首先要解決的問題是，他有多的入度為0的點，有就是說起點有好幾個，這樣是不能直接做DP的，所以這裡要用到一個技巧，我們設置一個超級原點(編號0)，連到那些入度為0的點，再去做後續的DP，就會好做很多。</p>
<p>並且當我們把超級原點加進去之後，會發現整個圖形變成了一棵樹，這時候就很明顯的要使用樹DP了。</p>
<p>至於轉移式的處理，這裡的轉移式不是單純的一個式子，而更像是背包DP那樣的轉移。</p>
<p>核心概念是，我們先把大問題簡化，假設有棵樹，根結點底下有x個子樹，我們已知關於這個子樹的所有數據，現在我們要做的是，決定從各個子樹裡面，要各自挑多少堂課，才會組成最大值。這裡就像是背包問題，只是從挑選要或不要，變成挑選各要拿幾個。</p>
<p>所以我們會試著找，這棵樹裡面我們總共要拿w堂課時，也就對應到背包問題的重量。然後枚舉子樹裡面要拿幾堂課(j)可以得到最大值，這樣就算是完成這個背包問題裡面的第一個物品(子樹)。</p>
<p>可以寫出轉移式:</p>
<script type="math/tex; mode=display">
    dp[v][w] = max(dp[v][w],dp[v][w-j]+dp[sub][j])</script><p>接著枚舉總共拿幾堂課的不同情況(不同w)，也就對應到背包問題的枚舉重量，得到挑到目前的子樹時，不同課數下的最大值。</p>
<p>然後換到下一個物品，繼續做同樣的枚舉，最後就可以得到，這棵樹中，拿多少堂課的最大值。</p>
<p>知道轉移式之後，我們只要照一般樹DP的作法，DFS到底部，再遞迴回來，就可以在我們的超級原點，得到整個圖來講，拿多少堂課可以得到的最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">305</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[MAXN]; <span class="comment">// 樹</span></span><br><span class="line"><span class="type">int</span> score[MAXN]; <span class="comment">// 紀錄這個點的分數</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN]; <span class="comment">// 點編號,選的課數</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[v].<span class="built_in">empty</span>()) <span class="keyword">return</span>; <span class="comment">// 到葉節點直接return</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> sub:tree[v])&#123; <span class="comment">// 枚舉子樹(物品)</span></span><br><span class="line">		<span class="built_in">DFS</span>(sub); <span class="comment">// 樹DP的基本作法，DFS下去</span></span><br><span class="line">        <span class="comment">// 接著做類似背包的轉移</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)&#123; <span class="comment">// 枚舉要拿幾堂課(必定包含自己，所以至少1)</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i<span class="number">-1</span>;j++)&#123; <span class="comment">// 枚舉這個子樹裡，要拿多少課最好</span></span><br><span class="line">				dp[v][i] = <span class="built_in">max</span>(dp[v][i], dp[v][i-j] + dp[sub][j]); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="type">int</span> k,s;</span><br><span class="line">	cin&gt;&gt;k&gt;&gt;s;</span><br><span class="line">	score[i] = s;</span><br><span class="line">	dp[i][<span class="number">1</span>] = s; <span class="comment">// 初始化，在點i當根節點的時候，只拿一個必定是自己</span></span><br><span class="line">	tree[k].<span class="built_in">push_back</span>(i); </span><br><span class="line">    <span class="comment">// 在這裡有k=0是沒有入度的情況</span></span><br><span class="line">    <span class="comment">// 所以我們直接把超級原點編號設0，就可以不用特殊處理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m++; <span class="comment">// 因為會多選到一個超級原點，所以要多加一個課程量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DFS</span>(<span class="number">0</span>); <span class="comment">// 從超級原點開始</span></span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	ans = <span class="built_in">max</span>(ans,dp[<span class="number">0</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/108353513">早めの夏!!暑すぎます☀️</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>普及+/提高</tag>
        <tag>DP</tag>
        <tag>樹</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P2047 [NOI2007] 社交網路</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P2047/</url>
    <content><![CDATA[<h2 id="題目-P2047-NOI2007-社交網路"><a href="#題目-P2047-NOI2007-社交網路" class="headerlink" title="題目: P2047 [NOI2007] 社交網路"></a>題目: <a href="https://www.luogu.com.cn/problem/P2047">P2047 [NOI2007] 社交網路</a></h2><p>首先，題目要我們求出，一個點的重要性，而這個重要性會從每條經過他的最短路徑加總而來，所以可以推測這題大概是多點源最短路。另外$N&lt;=100$，所以Floyd Warshall演算法的$N^3$時間複雜度是可以接受的。所以我們利用Floyd Warshall演算法來處理。</p>
<p>接著，從題目可以看出，我們需要兩個東西:</p>
<ol>
<li>i到j的最短路有幾個</li>
<li>i到j的最短路中，經過k的有幾個</li>
</ol>
<p>先假設i到j的最短路數量是path[i][j]</p>
<p>第一項可以透過Floyd Warshall進行更新時處理，當出現更短的路徑時，代表path[i][j]刷新。因為Floyd Warshall是在經過第k個點被鬆弛時更新，也就是會在k點的兩側各挑一條最短路，因此新的最短路數量就是path[i][k] * path[k]<a href="就基本的乘法原理">j</a>。</p>
<p>第二項，要確定某條最短路有沒有經過k，只要判斷path[i][k] + path[k][j]會不會等於path[i][j]，如果等於的話就一定是，大於顯然不是，也不會有小於的狀況，不然就出現更短的路徑了。而path[i][k] * path[k][j]就會是經過k的最短路數量。</p>
<p>最後在把兩者相除，即個得到k對於一組(i,j)的重要性，接著遍歷一遍即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line">vector&lt;pii&gt; vec[MAXN]; <span class="comment">// 圖</span></span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN]; <span class="comment">// 最短距離</span></span><br><span class="line"><span class="type">double</span> path[MAXN][MAXN]; <span class="comment">// 最短路徑數量</span></span><br><span class="line"><span class="type">double</span> imp[MAXN]; <span class="comment">// 重要性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">	dp[i][j] = <span class="number">10000000005</span>;</span><br><span class="line">	path[i][j]=<span class="number">1</span>; <span class="comment">// 這樣更新的時候才有值，不然就變成0*0</span></span><br><span class="line">	<span class="keyword">if</span>(i==j) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">	imp[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="type">int</span> a,b,w;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">	vec[a].<span class="built_in">push_back</span>(&#123;b,w&#125;);</span><br><span class="line">	dp[a][b] = w;</span><br><span class="line">	vec[b].<span class="built_in">push_back</span>(&#123;a,w&#125;);</span><br><span class="line">	dp[b][a] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==k || j==k) <span class="keyword">continue</span>; <span class="comment">// 避免出現用自己來更新，結果重複累加的狀況</span></span><br><span class="line">			<span class="keyword">if</span>(dp[i][j] &gt; dp[i][k] + dp[k][j])&#123;</span><br><span class="line">				dp[i][j] = dp[i][k] + dp[k][j];</span><br><span class="line">				path[i][j] = path[i][k] * path[k][j]; <span class="comment">// 因為是新的最短距離，所以重新給path一個值</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j] == dp[i][k] + dp[k][j])&#123;</span><br><span class="line">				path[i][j] += path[i][k] * path[k][j]; <span class="comment">// 因為是同個最距離，所以不重新給，用累加</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==k || j==k) <span class="keyword">continue</span>; <span class="comment">// 避免出現把自己更新自己記入的情況</span></span><br><span class="line">			<span class="keyword">if</span>(dp[i][k] + dp[k][j] == dp[i][j])&#123; <span class="comment">// 表示此最短路必定經k</span></span><br><span class="line">				<span class="keyword">if</span>(path[i][j]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">				imp[k] += path[i][k] * path[k][j] / path[i][j];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>)&lt;&lt;imp[k]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/108188130">メイド虹歌ちゃん</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>最短路</tag>
        <tag>Floyd-Warshall</tag>
        <tag>普及+/提高</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P2184 貪婪大陸</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P2184/</url>
    <content><![CDATA[<h2 id="題目-P2184-貪婪大陸"><a href="#題目-P2184-貪婪大陸" class="headerlink" title="題目: P2184 貪婪大陸"></a>題目: <a href="https://www.luogu.com.cn/problem/P2184">P2184 貪婪大陸</a></h2><p>一開始看到這題，我一直在想要怎麼同時維護區間最大值，又能夠去做增減的修改，但一直想不到解法。</p>
<p>但是圖畫出來後，會發現一件很酷的事情，這題的本質是一個區間裡面包了幾個區間，而區間與區間之間會有6個情況，針對6個情況去找共通點跟差異點就可以處理了。</p>
<p>6種情況如下:<br><img src="/洛谷/luogu-P2184/interval.png" alt=""></p>
<p>會增加區間中地雷種類的有: 部分在左、完全在內、部分在右、包住整個區間</p>
<p>可以發現他們的共通點是: 左端點全部在要求區間右端點的左側</p>
<p>不過這個特性也包含到了 完全在左，所以要找出完全在左跟這4個的差異性，也就是右端點在要求區間左端點的左側。</p>
<p>所以用(要求區間右端點左側的左端點) - (要求區間左端點左側的右端點)就可以求得會增加地雷種類的區間有幾個。</p>
<p>那這裡我們只要開兩個BIT分別維護左端點的區間值跟右端點的區間值，就可以解掉這題</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> bit_left[MAXN]; <span class="comment">// 維護左端點的BIT</span></span><br><span class="line"><span class="type">int</span> bit_right[MAXN]; <span class="comment">// 維護右端點的BIT</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本的BIT作法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> bit[], <span class="type">int</span> x, <span class="type">int</span> val)</span></span>&#123; </span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        bit[x] += val;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> bit[], <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ans += bit[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> q,l,r;</span><br><span class="line">        cin&gt;&gt;q&gt;&gt;l&gt;&gt;r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(q==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">modify</span>(bit_left, l, <span class="number">1</span>); <span class="comment">// 維護左端點值</span></span><br><span class="line">            <span class="built_in">modify</span>(bit_right, r, <span class="number">1</span>); <span class="comment">// 維護右端點值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="built_in">query</span>(bit_left, r) - <span class="built_in">query</span>(bit_right, l<span class="number">-1</span>); <span class="comment">// (要求區間右端點左側的左端點) - (要求區間左端點左側的右端點)</span></span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/103594107">虹夏ちゃん</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>資料結構</tag>
        <tag>區間</tag>
        <tag>BIT</tag>
        <tag>提高+/省選-</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P3387 【模板】縮點</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P3387/</url>
    <content><![CDATA[<h2 id="題目-P3387-【模板】縮點"><a href="#題目-P3387-【模板】縮點" class="headerlink" title="題目: P3387 【模板】縮點"></a>題目: <a href="https://www.luogu.com.cn/problem/P3387">P3387 【模板】縮點</a></h2><p>這算是tarjan-scc(找強連通分量的tarjan算法)的練習。題目中提到，路線可以重複走，不過每個點只能被計算一次，那顯然我們可以把一個可以從A點開始走，走回A點的子圖，也就是一個強連通分量，縮成一個點。因為要讓值最大，必定是把這個子圖裡面的點都走一遍，所以這個縮出來的點，點權就是這個子圖的所有點加總。</p>
<p>接著，得到縮完點的圖之後，會發現這個圖必定是DAG(有向無環圖)。因為每個點都是由一個強連通分量而來，如果兩個強連通分量之間，有環存在的話，他們兩個就會被併成一個強連通分量。</p>
<p>知道他是DAG後，我們就可以利用拓樸排序找最長路的方法，找到圖中權值最大的路徑。</p>
<p>順帶一提，這是tarjan的教學: <a href="https://oi-wiki.org/graph/scc/">強連通分量 - OI Wiki</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; gra[MAXN]; <span class="comment">// 原圖</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; gra_new[MAXN]; <span class="comment">// 縮完點的圖</span></span><br><span class="line"><span class="type">int</span> w[MAXN]; <span class="comment">// 點權</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DFN[MAXN];<span class="comment">// tarjan-scc的DFN</span></span><br><span class="line"><span class="type">int</span> LOW[MAXN]; <span class="comment">// tarjan-scc的LOW</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; sta; <span class="comment">// tarjan-scc的stack</span></span><br><span class="line"><span class="type">int</span> instack[MAXN]; <span class="comment">// tarjan-scc的stack的instack</span></span><br><span class="line"><span class="type">int</span> vis[MAXN]; <span class="comment">// 紀錄是tarjan否走過</span></span><br><span class="line"><span class="type">int</span> belong[MAXN]; <span class="comment">// 記錄該點屬於那個縮點</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; root; <span class="comment">// 記錄縮出來的點有哪些(編號)</span></span><br><span class="line"><span class="type">int</span> ind=<span class="number">0</span>; <span class="comment">// tarjan-scc的順序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> v)</span></span>&#123; <span class="comment">// 經典的tarjan算法</span></span><br><span class="line"></span><br><span class="line">	DFN[v] = ++ind;</span><br><span class="line">	LOW[v] = DFN[v];</span><br><span class="line">	sta.<span class="built_in">push_back</span>(v);</span><br><span class="line">	instack[v] = <span class="number">1</span>;</span><br><span class="line">	vis[v] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:gra[v])&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(i);</span><br><span class="line">			LOW[v] = <span class="built_in">min</span>(LOW[v],LOW[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(instack[i])&#123;</span><br><span class="line">			LOW[v] = <span class="built_in">min</span>(LOW[v],DFN[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(LOW[v] == DFN[v])&#123;</span><br><span class="line">		root.<span class="built_in">push_back</span>(v);</span><br><span class="line">		<span class="type">int</span> total = <span class="number">0</span>; <span class="comment">// 這個強連通分量中合起來的點權</span></span><br><span class="line">		<span class="type">int</span> u = sta.<span class="built_in">back</span>();</span><br><span class="line">		<span class="keyword">while</span>(u!=v)&#123;</span><br><span class="line">			belong[u] = v;</span><br><span class="line">			sta.<span class="built_in">pop_back</span>();</span><br><span class="line">			instack[u] = <span class="number">0</span>;</span><br><span class="line">			total += w[u]; <span class="comment">// 加上每個點</span></span><br><span class="line">			u = sta.<span class="built_in">back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		belong[u] = v; <span class="comment">// 該點屬於以u為根的縮點</span></span><br><span class="line">		sta.<span class="built_in">pop_back</span>();</span><br><span class="line">		instack[u] = <span class="number">0</span>;</span><br><span class="line">		total += w[u];</span><br><span class="line">		w[v] = total; <span class="comment">// 讓這個代表縮點的根，點權變成整個子圖的總量</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis_2[MAXN]; <span class="comment">// 紀錄DFS有沒有走過</span></span><br><span class="line"><span class="type">int</span> rd[MAXN]; <span class="comment">// 入度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> v)</span></span>&#123; <span class="comment">// 用來建立新圖的DFS</span></span><br><span class="line">	vis_2[v] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:gra[v])&#123;</span><br><span class="line">        <span class="comment">// 如果有不同縮點的點連接，相當於這兩個縮點連接</span></span><br><span class="line">		<span class="keyword">if</span>(belong[v]!=belong[i]) </span><br><span class="line">			gra_new[ belong[v] ].<span class="built_in">push_back</span>(belong[i]), rd[belong[i]]++;</span><br><span class="line">		<span class="keyword">if</span>(!vis_2[i])&#123;</span><br><span class="line">			<span class="built_in">DFS</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[MAXN]; <span class="comment">// 拓樸最長路的DP</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">topo</span><span class="params">()</span></span>&#123; <span class="comment">// 拓樸最長路</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:root)&#123;</span><br><span class="line">		dp[i] = w[i];</span><br><span class="line">		<span class="keyword">if</span>(rd[i]==<span class="number">0</span>) que.<span class="built_in">push</span>(i),ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:gra_new[u])&#123;</span><br><span class="line">			rd[i]--;</span><br><span class="line">			<span class="keyword">if</span>(rd[i]==<span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line">			dp[i] = <span class="built_in">max</span>(dp[i],w[i]+dp[u]);</span><br><span class="line">			ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	cin&gt;&gt;w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	gra[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">// 用for迴圈避免1號點走不到的地方被忽略</span></span><br><span class="line">	<span class="keyword">if</span>(!DFN[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">// 用for迴圈避免1號點走不到的地方被忽略</span></span><br><span class="line">	<span class="keyword">if</span>(!vis_2[i]) <span class="built_in">DFS</span>(i);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">topo</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 測試用測資</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8 9</span></span><br><span class="line"><span class="comment">1 2 4 8 16 32 64 128</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">3 6</span></span><br><span class="line"><span class="comment">7 4</span></span><br><span class="line"><span class="comment">4 1</span></span><br><span class="line"><span class="comment">1 8</span></span><br><span class="line"><span class="comment">8 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 輸出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">239</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/108016482">メイド虹夏〜！</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>拓樸排序</tag>
        <tag>普及+/提高</tag>
        <tag>tarjan</tag>
        <tag>最長路</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;新手教學題&gt; C++：從入門到放棄</title>
    <url>/%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%E9%A1%8C/newbie-C++%EF%BC%9A%E5%BE%9E%E5%85%A5%E9%96%80%E5%88%B0%E6%94%BE%E6%A3%84/</url>
    <content><![CDATA[<h2 id="題目-C-：從入門到放棄"><a href="#題目-C-：從入門到放棄" class="headerlink" title="題目: C++：從入門到放棄"></a>題目: <a href="http://mdcpp.mingdao.edu.tw/problem/T042">C++：從入門到放棄</a></h2><p>這題也是迴圈的應用，首先，我們可以看出，每複製一次行數會變成2倍。並且有兩種情況，要求的行數剛好是2的次方以及不是的，剛好是2的次方，則一直複製全部，直到相等就停止。不是2的次方的情況，一樣複製全部，複製到超過他的那一次時，會發現我們多複製了一些，事實上只要這次不要複製那麼多，指複製需要的，那也會在這一次滿足。</p>
<p>所以說，2的次方=&gt;等於時停止，非2的次方=&gt;大於時停止，所以只要行數小於(非等於、大於就是小於了)要求時，就一直複製全部，每複製一次，增加一次次數，就可以算出答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t; <span class="comment">// 有t組詢問</span></span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin&gt;&gt;a; <span class="comment">// 要求的數字</span></span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>; <span class="comment">// 行數</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>; <span class="comment">// 複製次數</span></span><br><span class="line">        <span class="keyword">while</span>(num&lt;a)&#123; <span class="comment">// 承上敘述，小於時，就一直複製</span></span><br><span class="line">            num *= <span class="number">2</span>; <span class="comment">// 複製成兩倍</span></span><br><span class="line">            ans++; <span class="comment">// 每複製一次，次數+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/106379296">虹夏ちゃんと</a></p>
<hr>
]]></content>
      <categories>
        <category>新手教學題</category>
      </categories>
      <tags>
        <tag>新手教學題</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P5020 [NOIP2018 提高組] 貨幣系統</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P5020/</url>
    <content><![CDATA[<h2 id="題目-P5020-NOIP2018-提高組-貨幣系統"><a href="#題目-P5020-NOIP2018-提高組-貨幣系統" class="headerlink" title="題目: P5020 [NOIP2018 提高組] 貨幣系統"></a>題目: <a href="https://www.luogu.com.cn/problem/P5020">P5020 [NOIP2018 提高組] 貨幣系統</a></h2><p>看到這種找錢問題，就是個很標準的無限背包問題，不知道的可以參考<a href="https://web.ntnu.edu.tw/~algo/KnapsackProblem.html#8">演算法筆記 Coin Change Problem</a>。</p>
<p>不過，從題目的條件中，我們找不到到底該枚舉到多少，去確認他是否可以被湊出來。</p>
<p>讓我們先回到題目來看，他希望我們在保證貨幣系統一樣的情況下，讓貨幣的種類越少越好。這時我們有兩種想法:</p>
<ol>
<li>構造一個跟原本數組完全無關的數組，不過兩者系統等價</li>
<li>把原本數組簡化，讓他的貨幣種類變少</li>
</ol>
<p>關於第一種方法，我寫的當下不知道怎麼證明，所以就直接嘗試了第二種方法。關於第一種方法的證明，可以參考<a href="https://www.luogu.com.cn/blog/0x3meow/solution-p5020">题解 P5020 【货币系统】</a></p>
<p>至於第二種方法，要把數組簡化，就是把那先不必要出現的貨幣種類刪除，也就是可以被其他貨幣湊出來的。</p>
<p>既然知道這個，那我們就可以知道套回找錢問題中，我們希望判斷是否能被湊出來的最大值，就會是現有貨幣的最大值。此題的a&lt;25000也可以讓我們在無限背包的時間複雜度下完成。</p>
<p>實作上，因為一定是用小面額去湊大面額，所以我們要先排序一遍，從最小的面額開始去湊，過程中，如果能把大面額湊出來，就把他刪掉，最後看剩下多少就是答案了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">25005</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">	<span class="type">int</span> dp[MAXN]; <span class="comment">// 是否能被湊出</span></span><br><span class="line">	<span class="type">int</span> exist[MAXN]; <span class="comment">// 這個面額是否存在</span></span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	<span class="built_in">memset</span>(exist,<span class="number">0</span>,<span class="built_in">sizeof</span>(exist));</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		exist[a] = <span class="number">1</span>;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>()); <span class="comment">// 為了從小開始，排序</span></span><br><span class="line"></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:vec)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> w=i;w&lt;=(*vec.<span class="built_in">rbegin</span>());w++)&#123; <span class="comment">// 最大值為排序完的最後一項</span></span><br><span class="line">		dp[w] = dp[w] | dp[w-i];</span><br><span class="line">        <span class="comment">// 如果可以被別的面額湊出，並且存在，則刪除</span></span><br><span class="line">		<span class="keyword">if</span>(dp[w]==<span class="number">1</span> &amp;&amp; exist[w] == <span class="number">1</span> &amp;&amp; w!=i)&#123;</span><br><span class="line">			<span class="keyword">auto</span> iter = <span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),w);</span><br><span class="line">			vec.<span class="built_in">erase</span>(iter);</span><br><span class="line">			exist[w] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;vec.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/106379296">BoNiji(ぼ虹)</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>普及+/提高</tag>
        <tag>DP</tag>
        <tag>背包</tag>
        <tag>無限背包</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;新手教學題&gt; 大富翁</title>
    <url>/%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%E9%A1%8C/newbie-%E5%A4%A7%E5%AF%8C%E7%BF%81/</url>
    <content><![CDATA[<p>這一題的核心，就是模擬大富翁的走路，首先我們要先用陣列儲存所有格子上的數字。接著開一個變數step代表目前所在的格子，從0開始，也就是從第0格開始。再開一個初始值為0的變數cost，代表加起來的過路費。然後開始累加骰子的數值，每累加一次，也就是走一步，就要把過路費加到cost上面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;arr[i]; <span class="comment">// 儲存每一格過路費的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>; <span class="comment">// 所在的格子數，題目有說從第0格開始</span></span><br><span class="line">    <span class="type">int</span> cost = <span class="number">0</span>; <span class="comment">// 所花的過路費</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123; <span class="comment">// 做m次</span></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        cin&gt;&gt;b;</span><br><span class="line">        step += b; <span class="comment">// 往前走b格</span></span><br><span class="line">        cost += arr[step]; <span class="comment">// 加上腳下這個格子的過路費</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cost&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/106953959">虹夏ちゃん</a></p>
<hr>
]]></content>
      <categories>
        <category>新手教學題</category>
      </categories>
      <tags>
        <tag>新手教學題</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;新手教學題&gt; 簡單費氏數列</title>
    <url>/%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%E9%A1%8C/newbie-%E7%B0%A1%E5%96%AE%E8%B2%BB%E6%B0%8F%E6%95%B8%E5%88%97/</url>
    <content><![CDATA[<h2 id="題目-簡單費氏數列"><a href="#題目-簡單費氏數列" class="headerlink" title="題目: 簡單費氏數列"></a>題目: <a href="http://mdcpp.mingdao.edu.tw/problem/B001">簡單費氏數列</a></h2><p>這題不用看題目，直接看標題就行，就是要找費氏數列，不知道費氏數列是什麼的可以google，費式數列的每一項都是前二項相加，所以我們可以用for迴圈直接推導到第30項(N&lt;=30)，並用陣列儲存答案，再來他問哪一項我們就答哪一項</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">35</span>]; <span class="comment">// 費式數列的值，題目只要求N&lt;=30，所以這裡開35</span></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T; <span class="comment">// 詢問次數</span></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 初始值</span></span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">2</span>; <span class="comment">// 初始值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">30</span>;i++)&#123;</span><br><span class="line">         arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>]; <span class="comment">// 費式數列的算法: 前二項相加=這一項</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin&gt;&gt;a; <span class="comment">// 問第a項</span></span><br><span class="line">        cout&lt;&lt;arr[a]&lt;&lt;endl; <span class="comment">// 回答第a項的答案</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源:<a href="https://www.pixiv.net/artworks/104730590">虹夏ちゃん</a></p>
<hr>
]]></content>
      <categories>
        <category>新手教學題</category>
      </categories>
      <tags>
        <tag>新手教學題</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P2827 [NOIP2016 提高組] 蚯蚓</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P2827/</url>
    <content><![CDATA[<h2 id="題目-P2827-NOIP2016-提高組-蚯蚓"><a href="#題目-P2827-NOIP2016-提高組-蚯蚓" class="headerlink" title="題目: P2827 [NOIP2016 提高組] 蚯蚓"></a>題目: <a href="https://www.luogu.com.cn/problem/P2827">P2827 [NOIP2016 提高組] 蚯蚓</a></h2><h2 id="90分解"><a href="#90分解" class="headerlink" title="90分解:"></a>90分解:</h2><p>看到這個題目，我第一個想到的就是用<strong>priority_queue</strong>來維護，一個一個找出最長的蟲子，並做操作。</p>
<p>其中，需要處理的是，每隻蟲子會成長的問題。因為不可能把資結裡面的所有蟲子都加上成長量，因此我們換個思路。因為在資結裡的資料，重點是要比大小，因此只要能讓他的大小順序保持住就好。那我們就不對資料結構裡面的所有蟲加上成長量，反過來把新加入的蟲(切出來的)減去成長量，他們之間的相對值就能維持住。另外開一個變數來記錄總成長量，當我們需要求蟲的長度時，再把成長量加回去就可以得到值了。</p>
<p>這個方法的複雜度是$O(MlogN)$，我本來預期會過，不過出題者好像把這個複雜度卡掉了。如果壓常很強的話，搞不好可以透過這個方法AC?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line"><span class="type">int</span> n,m,q,t;</span><br><span class="line"><span class="type">double</span> u,v;</span><br><span class="line"><span class="type">double</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;q&gt;&gt;u&gt;&gt;v&gt;&gt;t;</span><br><span class="line">	<span class="type">int</span> num = n; <span class="comment">// 用來記錄目前有幾隻蟲</span></span><br><span class="line">	p = u/v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">double</span> temp;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		pq.<span class="built_in">push</span>(temp); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> len_add = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> longest = pq.<span class="built_in">top</span>() + len_add; </span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(i%t==<span class="number">0</span>)&#123;</span><br><span class="line">			cout&lt;&lt;longest&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		num--;</span><br><span class="line">		len_add += q; <span class="comment">// 總成長量為 m*q</span></span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">int</span>(longest * p);</span><br><span class="line">		<span class="type">int</span> b = longest - a;</span><br><span class="line">		pq.<span class="built_in">push</span>(a - len_add ); <span class="comment">// 減去總成長量，等於前面這一段時間的成長量都沒有吃掉</span></span><br><span class="line">		pq.<span class="built_in">push</span>(b - len_add);</span><br><span class="line">		num += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%t==<span class="number">0</span>)</span><br><span class="line">			cout&lt;&lt;pq.<span class="built_in">top</span>() + len_add&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 因為有減去，所以拿出來的時候，加回來</span></span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="100分解"><a href="#100分解" class="headerlink" title="100分解:"></a>100分解:</h2><p>這個方法是利用單調性來維護，就可以去掉$logN$的複雜度，把剩下的十分拿下。</p>
<p>不過這是我看題解思路寫的，我自己真的沒有觀察出他有單調性。</p>
<p>首先，要觀察出一件事，<strong>先被切出來的蟲，一定比後被切出來的蟲長</strong><br>假設目前最大的兩隻蟲為$a,b$，$a&gt;b$<br>過一秒後，$a$被切成$pa,(1-p)a$，$b$成長為$b+q$<br>再過一秒，$a$的兩條蟲成長為$pa+q,(1-p)a+q$，$b$被切成$pb+pq,(1-p)b+(1-p)q$<br>因為$a&gt;b$，$0 &gt; p &gt; 1$，所以$pa+q &gt; pb+pq$，$(1-p)a+q &gt; (1-p)b+(1-p)q$<br>可以發現切出來的蟲中，較長蟲一定比後面切出的較長蟲更長，較短蟲一定比後面切出的較短蟲更長<br>接下來兩者的成長都是同時發生，所以相對大小不變<br>發現他的單調性，再把它分成另外兩堆，就可以不用priority_queue來維護了<br>找最長的蟲時，只要從這兩堆，跟原本還沒被切過的那堆(3堆)中，挑出來最大的就行了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; non_dq; <span class="comment">// 沒被切的蟲</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq_min; <span class="comment">// 切出來較短的蟲</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq_max; <span class="comment">// 切出來較長的蟲</span></span><br><span class="line"><span class="type">int</span> n,m,q,t;</span><br><span class="line"><span class="type">double</span> u,v;</span><br><span class="line"><span class="type">double</span> p;</span><br><span class="line"><span class="type">int</span> len_add = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_longest</span><span class="params">()</span></span>&#123; <span class="comment">// 從3堆中找最大值得函式，我寫的比較醜一點</span></span><br><span class="line">	<span class="type">int</span> longest;</span><br><span class="line">	<span class="keyword">if</span>(dq_max.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(dq_min.<span class="built_in">empty</span>())</span><br><span class="line">			longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(non_dq.<span class="built_in">empty</span>())</span><br><span class="line">			longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(non_dq.<span class="built_in">back</span>() &gt;= dq_min.<span class="built_in">back</span>())</span><br><span class="line">				longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(dq_min.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(dq_max.<span class="built_in">empty</span>())</span><br><span class="line">			longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(non_dq.<span class="built_in">empty</span>())</span><br><span class="line">			longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(non_dq.<span class="built_in">back</span>() &gt;= dq_max.<span class="built_in">back</span>())</span><br><span class="line">				longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(non_dq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(dq_max.<span class="built_in">empty</span>())</span><br><span class="line">			longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dq_min.<span class="built_in">empty</span>())</span><br><span class="line">			longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(dq_max.<span class="built_in">back</span>() &gt;= dq_min.<span class="built_in">back</span>())</span><br><span class="line">				longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dq_min.<span class="built_in">back</span>() &gt;= dq_max.<span class="built_in">back</span>() &amp;&amp; dq_min.<span class="built_in">back</span>() &gt;= non_dq.<span class="built_in">back</span>())</span><br><span class="line">			longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dq_max.<span class="built_in">back</span>() &gt;= dq_min.<span class="built_in">back</span>() &amp;&amp; dq_max.<span class="built_in">back</span>() &gt;= non_dq.<span class="built_in">back</span>())</span><br><span class="line">			longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;q&gt;&gt;u&gt;&gt;v&gt;&gt;t;</span><br><span class="line">	<span class="type">int</span> num = n;</span><br><span class="line">	p = u/v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">double</span> temp;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		non_dq.<span class="built_in">push_back</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(non_dq.<span class="built_in">begin</span>(), non_dq.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> longest = <span class="built_in">find_longest</span>();</span><br><span class="line">		<span class="keyword">if</span>(i%t==<span class="number">0</span>)&#123;</span><br><span class="line">			cout&lt;&lt;longest&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		num--;</span><br><span class="line">		len_add += q;</span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">int</span>(longest * p);</span><br><span class="line">		<span class="type">int</span> b = longest - a;</span><br><span class="line">		<span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(a,b); <span class="comment">// 保持a是比較長的那隻</span></span><br><span class="line">		dq_max.<span class="built_in">push_front</span>(a - len_add); <span class="comment">// 把較長的蟲，跟較短的蟲分開維護</span></span><br><span class="line">		dq_min.<span class="built_in">push_front</span>(b - len_add);</span><br><span class="line">		num += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">		<span class="type">int</span> longest = <span class="built_in">find_longest</span>();</span><br><span class="line">		<span class="keyword">if</span>(i%t==<span class="number">0</span>)</span><br><span class="line">			cout&lt;&lt;longest&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/106276835">虹夏ちゃん✨</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>提高+/省選-</tag>
        <tag>單調</tag>
        <tag>priority_queue</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;新手教學題&gt; 輝夜姬的3N+1猜想</title>
    <url>/%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%E9%A1%8C/newbie-%E8%BC%9D%E5%A4%9C%E5%A7%AC%E7%9A%843N-1%E7%8C%9C%E6%83%B3/</url>
    <content><![CDATA[<h2 id="題目-輝夜姬的3N-1猜想"><a href="#題目-輝夜姬的3N-1猜想" class="headerlink" title="題目: 輝夜姬的3N+1猜想"></a>題目: <a href="http://mdcpp.mingdao.edu.tw/problem/T001">輝夜姬的3N+1猜想</a></h2><p>這題是while迴圈的應用，因為我們不確定他會在甚麼時候才完成操作，所以必須使用while迴圈，在達成條件，X==1之前，不斷重複操作。</p>
<p>在迴圈運行時，我們要預先開一個變數，用來計算迴圈跑的次數，也就是操作次數，迴圈每跑一次就+1，等迴圈結束，所得的值就是X變成1的操作次數。</p>
<p>順帶一提，這裡用到了while(T—)的寫法，這代表跑T次的意思，因為當T次跑完，T就會減至0，也就是false的意思，會導致迴圈停止，所以迴圈就會剛好只跑T次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123; <span class="comment">// 這部分請看解說第3段</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> X; <span class="comment">// 題目要求用long long存</span></span><br><span class="line">        cin&gt;&gt;X;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>; <span class="comment">// 操作次數</span></span><br><span class="line">        <span class="keyword">while</span>(X!=<span class="number">1</span>)&#123; <span class="comment">// 不斷迴圈，直到X達到條件</span></span><br><span class="line">            num++; <span class="comment">// 每跑一次，操作次數+1</span></span><br><span class="line">            <span class="keyword">if</span>(X%<span class="number">2</span>==<span class="number">0</span>) <span class="comment">// 偶數操作</span></span><br><span class="line">                X = X/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 奇數操作</span></span><br><span class="line">                X = X*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>新手教學題</category>
      </categories>
      <tags>
        <tag>新手教學題</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; Dijkstra單點源最短路演算法</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-Dijkstra/</url>
    <content><![CDATA[<p>Dijkstra演算法，戴克斯特拉演算法，用來解決單點源最短路問題的演算法。</p>
<p>講Dijkstra之前，我們要先了解鬆弛的概念，鬆弛就是兩個點之間，出現了一條更短路徑。舉例來講，a到b的距離是10，a到c到b的距離是8，因為出現了更短的路徑，因此我們說，c鬆弛了a到b。</p>
<p>Dijkstra的核心在於，我們在找最短路時，每次都選擇目前距離最近的點。因為其他點的距離都更遠，不可能去利用其他點來鬆弛這個點，所以這個點現在的距離保證會是他的最短距離。之後我們可以再利用這個保證是最短路徑的點，去試著鬆弛其他點。</p>
<p><img src="/演算法教學/algorithm-Dijkstra/Dijkstra.gif" alt=""></p>
<p>實作上，我們會利用priority_queue來達成，我們會把每個新被鬆弛出來的點，丟進去priority_queue裡面，並且把裡面最小的取出來，再用這個點去鬆弛其他點。</p>
<p>順帶一提，Dijkstra不能用在有負環的圖上，關於這個，我們會在下一篇的SPFA演算法中提到</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><p>時間複雜度$O(NlogN)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; gra[MAXN]; <span class="comment">// 圖</span></span><br><span class="line"><span class="type">int</span> dis[MAXN]; <span class="comment">// 記錄距離</span></span><br><span class="line"><span class="type">int</span> vis[MAXN]; <span class="comment">// 記錄是不是確定是最短路徑，並且鬆弛過別人了</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ,vector&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;,greater&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; &gt; pq;</span><br><span class="line"><span class="comment">// greater 代表由小到大</span></span><br><span class="line"><span class="comment">// 裡面的儲存格式為&#123;dis[a],a&#125;，把點權放前面是因為priority_queue會優先以first項來排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果已經確定是最短路徑，後面得到的值一定不是最短的，直接丟掉換下一個</span></span><br><span class="line">    <span class="keyword">if</span>(vis[s])&#123; </span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="built_in">dijkstra</span>(pq.<span class="built_in">top</span>().S);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[s] = <span class="number">1</span>; <span class="comment">// 被拿來鬆弛其他人</span></span><br><span class="line"></span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(pair&lt;<span class="type">int</span>,<span class="type">int</span> &gt; i:gra[s])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i.F]&gt;dis[s]+i.S)&#123; <span class="comment">// 鬆弛成功 // i.S表示邊權</span></span><br><span class="line">            dis[i.F] = dis[s]+i.S; <span class="comment">// 更新距離</span></span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;dis[i.F],i.F&#125;); <span class="comment">// 有了更小的距離，因此丟進priority_queue中比較</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="built_in">dijkstra</span>(pq.<span class="built_in">top</span>().S); <span class="comment">// 找下一個目前最近的點是誰</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/103214931">虹夏</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
</search>
